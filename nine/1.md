笔记
===================

[TOC]

## 问题显现

### 遗留代码

软件有一定的生命周期。在程序的整个生命历程中，总会由于新的需求、老的bug等导致修改和添加补丁。没有测试、没有文档，很久前构建的软件。

### 新代码构建：传统的瀑布模型

瀑布模型借鉴于建筑行业，是一种顺流而下（需求分析设计->实现->集成->测试->安装->维护）的软件构建方法。

但是软件开发和传统行业存在很大的不同:
1、一开始的时候并不知道真正的需求是什么
2、开发过程不仅仅是准备好部件进行组装
3、整个开发流程和使用中都会有新的需求或修改需求导致软件的修改

### 孤注一掷：瀑布模型的风险积累

瀑布模型到集成阶段才将所有的独立代码合并到一起，这等于是在持续积累风险。

有很多bug只有在集成阶段才会出现。而在集成极端修复bug又有很高的代价。

### 瀑布模型的无力之处：

- 在编码后需要等待很久之后的集成才能看到结果。
- 软件构建和现实情况有很大的不同。软件的功能测试需要依赖上下文环境。
- 软件后期存在需求修改等。而在集成后难以修改（需要考虑重新编译，对整体功能的重新测试等）。

#### 软件开发的独特之处：

1. 软件开发不是在严格规则或图纸指导下的亦步亦趋。开发过程中有许多初次涉足的情境。
2. 开发和测试要紧密结合。开发者不能只关注于任务的完成而忽视质量。

### 过度的流程：

必须要求注释 导致 充满流水帐的注释。
代码应该是自解释的，通过优秀的命名和通行的方法使得易于理解。
还有许多像要求注释这样的流程，出于良好的初衷，却适得其反

过度的流程导致敷衍。

### 过度的管理：

软件开发是一个创造性的工作，而流程无法支配创造力。强制推行负责的制度计划只会适得其反

### 充满谎言：

在开发前期的评估和设计，其实都是对开发进度的猜测。
没有完整可靠的公式可以计算出整个项目所需要的时间。

事实上整个项目都是在基于前期猜测的进度上进行，所以可能延期而不自知。

### 评估未知 

同上，很多时候开发的东西是从未做过的，也无法准确的知晓所需的时间。一项创造性的工作也很难用时间来衡量。所以在动手开发前，很多的评估是对未知的东西的评估。

### 没有公认的标准

软件产业仍是一个年轻的产业。到现在还没有广泛接受的标准和实践来指导软件开发。

## 逃出混乱

### 项目为何会失败

通过研究发现，项目失败是普遍存在的，其中有3个导致低成功率的因素：
- 代码变更
- bug修复
- 复杂度控制

#### 软件需要修改

软件不会自己更新自己，但是从它被投入使用开始 总会需要更改。而更改代码则会带来问题：
1. 因为阅读代码十分费力，所以遇到大范围修改，人们倾向于重写代码。
2. 多数软件未考虑到以后扩展，所以添加功能需要重新设计。这样可能代价和风险很高。
3. 重新修改部分代码可能需要重新执行所有的测试。

与其弄清现有设计，不如直接修改的方式系统的代码质量下降，且使以后的扩展更加困难。
  
#### bug泛滥

可能一个小bug会牵扯出更多的问题，如果软件被编写的盘根错节，则可能修改bug的过程会变成无穷无尽的修改。

bug是软件开发流程中的缺陷。

#### 软件复杂度的增长

很多功能可能从未被使用，可是却导致的软件复杂度的增加。因为瀑布模型只有一次列出需求的机会。
开发者很多时候觉得顺手添加的功能，即过度开发。

### 失败的代价

1. 低效的软件构建方式导致大量损失
2. 80%的软件开销用于软件维护、优化、修复。

## 软件开发 新方法

### 什么是 敏捷

软件开发中的浪费：大量已经开展但是未完成的任务，即没有给客户带来实际价值的东西。

敏捷的核心就是通过持续不断地及早交付有价值的软件使客户满意。即精简流程，将精力更多的投入到工程实践。

### 短程目标

软件开发很难确定 整个项目需要多久，无法估计项目的终点。所以不如以一个个里程碑的形式，将注意力转移到一小部分中。

### 如何实现

### 艺术与技能的平衡

### 敏捷跨越鸿沟

对创新产品接受的5个群体：
- 创新者首批采用
- 受到成功经验的启发，早期实践者下一批采用
- 开始出现很多操作指南，技术开始易用，多数派先行者开始加入
- 在前者的帮助下，开始成为主流，多数派后行者也加入
- 滞后者别无选择。

敏捷已经被早期实践者所接受，并且已经逐渐渗透到多数派先行者中。

### 追求技术卓越

